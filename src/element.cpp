///////////////////////////////////////////////////////////////////////////////
// element.C: 2D quad spectral element class routines.
//
// Copyright (c) 1994 <--> $Date: 2015/04/20 11:14:18 $, Hugh Blackburn
//
// --
// This file is part of Semtex.
// 
// Semtex is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
// 
// Semtex is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Semtex (see the file COPYING); if not, write to the Free
// Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
// 02110-1301 USA.
///////////////////////////////////////////////////////////////////////////////

static char RCS[] = "$Id: element.cpp,v 8.1 2015/04/20 11:14:18 hmb Exp $";

#include <sem.h>


Element::Element (const int_t id,
		  const int_t np,
		  const Mesh* M ) :
// ---------------------------------------------------------------------------
// Create a new quad element, n x n.  Node spacing along any side
// generated by mapping z (defined on domain [-1, 1], np points) onto
// side.
//
// Compute information for internal storage, and economise.
// ---------------------------------------------------------------------------
  _id   (id),
  _np   (np),
  _npnp (_np * _np),
  _next (4 * (_np - 1)),
  _nint (_npnp - _next),
  _cyl  (Geometry::cylindrical())
{
  const char routine[] = "Element::Element";

  if (_np < 2) message (routine, "need > 2 knots for element edges", ERROR);

  Femlib::quadrature (&_zr, &_wr, &_DVr, &_DTr, _np, GLJ, 0.0, 0.0);

  // -- Make special SVV-modified differentiation matrices if required.

  SVV::operators (_np, &_SDVr, &_SDTr);
    
  // -- Fill in aliases for equal-order elements.

  _zs = _zr; _ws = _wr; _DVs = _DVr; _DTs = _DTr; _SDVs = _SDVr; _SDTs = _SDTr;

  // -- Build edge-mapping permutation vectors.

  Femlib::buildMaps  (_np, 2, &_emap, &_pmap);
  
  _xmesh = new real_t [static_cast<size_t> (_npnp)];
  _ymesh = new real_t [static_cast<size_t> (_npnp)];
  _drdx  = new real_t [static_cast<size_t> (_npnp)];
  _dsdx  = new real_t [static_cast<size_t> (_npnp)];
  _drdy  = new real_t [static_cast<size_t> (_npnp)];
  _dsdy  = new real_t [static_cast<size_t> (_npnp)];
  _Q1    = new real_t [static_cast<size_t> (_npnp)];
  _Q2    = new real_t [static_cast<size_t> (_npnp)];
  _Q3    = new real_t [static_cast<size_t> (_npnp)];
  _Q4    = new real_t [static_cast<size_t> (_npnp)];
  _Q8    = new real_t [static_cast<size_t> (_npnp)];
  _delta = new real_t [static_cast<size_t> (_npnp)];
  
  M -> meshElmt (_id, _np, _zr, _zs, _xmesh, _ymesh);
 
  this -> mapping();

  Family::adopt (_npnp, &_xmesh);
  Family::adopt (_npnp, &_ymesh);
  Family::adopt (_npnp, &_drdx );
  Family::adopt (_npnp, &_drdy );
  Family::adopt (_npnp, &_dsdx );
  Family::adopt (_npnp, &_dsdy );
  Family::adopt (_npnp, &_Q1   );
  Family::adopt (_npnp, &_Q2   );
  Family::adopt (_npnp, &_Q3   );
  Family::adopt (_npnp, &_Q4   );
  Family::adopt (_npnp, &_Q8   );
  Family::adopt (_npnp, &_delta);

#if defined (DAMPING)
  // -- Compile-in hack for LES.
#include "damping.C"
  // -- Van Driest damping.
  // An ad-hoc modification to mesh length scale to account for wall
  // effects in LES.  This example is for a pipe flow, radius 0.5.
  // Femlib::prepVec
  // ("delta x y","delta*sqrt(1-exp(-(75.27*abs(0.5-sqrt(x*x+y*y)))^3))");
  // Femlib__parseVec (_npnp, _delta, _xmesh, _ymesh, _delta);
#endif

}


Element::~Element ()
// ---------------------------------------------------------------------------
// Clean up internal storage using Femlib family routines.
// ---------------------------------------------------------------------------
{
  Family::abandon (&_xmesh);
  Family::abandon (&_ymesh);
  Family::abandon (&_delta);

  Family::abandon (&_drdx );
  Family::abandon (&_dsdx );
  Family::abandon (&_drdy );
  Family::abandon (&_dsdy );

  Family::abandon (&_Q1   );
  Family::abandon (&_Q2   );
  Family::abandon (&_Q3   );
  Family::abandon (&_Q4   );
  Family::abandon (&_Q8   );
}


void Element::HelmholtzSC (const real_t lambda2,
			   const real_t betak2 ,
			   real_t*      hbb    ,
			   real_t*      hbi    ,
			   real_t*      hii    ,
			   real_t*      rmat   ,
			   real_t*      rwrk   ,
			   int_t*       iwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix and return the
// statically condensed form in hbb, the interior-exterior coupling
// matrix in hbi, and the interior resolution matrix factor in hii.
//
// lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Uncondensed System   -->   Statically condensed form returned in hbb.
//
//                                                           -1
//  +---------+------+       +---------+    +------+  +------+  +---------+
//  |         |      |       |         |    |      |  |      |  |         |
//  |         |      |       |         |    |      |  | hii  |  |   hib   |
//  |   hbb   | hbi  |  -->  |   hbb   | -  | hbi  |  |      |  |         |
//  |         |      |       |         |    |      |  +------+  +---------+
//  |         |      |       |         |    |      |
//  +---------+------+       +---------+    +------+
//  |         |      |
//  |   hib   | hii  |
//  |         |      |
//  +---------+------+
//
// Element matrices are built row-by-row, sorted to place entries for
// internal nodes first, posted into local partitions.  Then the
// internal resolution matrix hii is factorized and the static
// condensation completed.  In addition, the interior-exterior
// partition hbi is postmultiplied by hii(inverse) for convenience in
// the resolution stage.
//
// hbb:    nExt  by nExt    matrix;  (row-major 1D storage).
// hbi:    nExt  by nInt    matrix;  (row-major 1D storage).
// hii:    nInt  by nInt    matrix;  (row-major 1D storage).
// rmat:   nKnot by nKnot   matrix;  (row-major 1D storage).
// rwrk:   nExt*(nExt+nInt) vector.
// iwrk:   nInt             vector.
// ---------------------------------------------------------------------------
{
  const char     routine[] = "Element::HelmholtzSC";
  register int_t i, j, eq, info, ij = 0;

  // -- Construct hbb, hbi, hii partitions of elemental Helmholtz matrix.

  for (i = 0; i < _np; i++)
    for (j = 0; j < _np; j++, ij++) {

      this -> HelmholtzRow (lambda2, betak2, i, j, rmat, rwrk);

      Veclib::gathr (_npnp, rmat, _emap, rwrk);

      if ( (eq = _pmap[ij]) < _next ) {
	Veclib::copy (_next, rwrk,         1, hbb + eq * _next, 1);
	Veclib::copy (_nint, rwrk + _next, 1, hbi + eq * _nint, 1);
      } else
	Veclib::copy (_nint, rwrk + _next, 1, hii + (eq - _next) * _nint, 1);
    }

  // -- Static condensation.

  if (_nint) {

    Lapack::getrf (_nint, _nint, hii, _nint, iwrk, info);
    if (info) message (routine, "matrix hii has singular factor", ERROR);

#if defined (DEBUG)
  if (Femlib::ivalue ("VERBOSE") > 3)
    this -> printMatSC (hbb, hbi, hii);
#endif

    Lapack::getri (_nint, hii, _nint, iwrk, rwrk, _nint*_next, info);
    if (info) message (routine, "matrix hii is singular", ERROR);

    Blas::mxm    (hbi, _next, hii, _nint, rwrk, _nint);
    Blas::mxmts  (rwrk, _next, hbi, _nint, hbb, _next);
    Veclib::copy (_nint*_next, rwrk, 1, hbi, 1);
  }
}


void Element::printMatSC (const real_t* hbb,
			  const real_t* hbi,
			  const real_t* hii) const
// ---------------------------------------------------------------------------
// (Debugging) utility to print up element matrices.
// ---------------------------------------------------------------------------
{
  int_t i, j;

  cout << "-- Helmholtz matrices, element " << _id << endl;

  cout << "-- hbb:" << endl;

  cout.precision(3);

  for (i = 0; i < _next; i++) {
    for (j = 0; j < _next; j++)
      cout << setw (10) << hbb[Veclib::row_major (i, j, _next)];
    cout << endl;
  }

  cout << "-- hii:" << endl;

  for (i = 0; i < _nint; i++) {
    for (j = 0; j < _nint; j++)
      cout << setw (10) << hii[Veclib::row_major (i, j, _nint)];
    cout << endl;
  }

  cout << "-- hbi:" << endl;

  for (i = 0; i < _next; i++) {
    for (j = 0; j < _nint; j++)
      cout << setw (10) << hbi[Veclib::row_major (i, j, _nint)];
    cout << endl;
  }

  cout.precision(6);
}


void Element::Helmholtz (const real_t lambda2,
			 const real_t betak2 ,
			 real_t*      h      ,
			 real_t*      rmat   ,
			 real_t*      rwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix, return in h.
//
// This routine can be used when static condensation is not employed,
// and is included mainly to ease checking of entire element matrices.
// Node ordering produced is row-major.
//
// h:    vector, length np*np*np*np;
// rmat: vector, length np*np;
// ---------------------------------------------------------------------------
{
  register int_t i, j, ij = 0;

  for (i = 0; i < _np; i++)
    for (j = 0; j < _np; j++, ij++) {
      this -> HelmholtzRow (lambda2, betak2, i, j, rmat, rwrk);
      Veclib::copy (_npnp, rmat, 1, h + ij * _np, 1);
    }
}

       
void Element::local2global (const real_t* src     ,
			    const int_t*  btog    ,
			    real_t*       external,
			    real_t*       internal) const
// ---------------------------------------------------------------------------
// Load values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, src, _emap, btog, external);
  if (internal) Veclib::gathr (_nint, src, _emap + _next, internal);
}


void Element::local2globalSum (const real_t* src     ,
			       const int_t*  btog    ,
			       real_t*       external,
			       real_t*       internal) const
// ---------------------------------------------------------------------------
// Sum values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr_sum (_next, src, _emap,  btog, external);
  if (internal) Veclib::gathr_sum (_nint, src, _emap + _next, internal);
}


void Element::global2local (real_t*       tgt     ,
			    const int_t*  btog    ,
			    const real_t* external,
			    const real_t* internal) const
// ---------------------------------------------------------------------------
// From (globally-numbered) external & internal partitons of vector,
// load into elemental storage tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, external, btog,  _emap, tgt);
  if (internal) Veclib::scatr (_nint, internal, _emap + _next, tgt);
}


void Element::local2globalSumSC (real_t*       F   ,
				 const int_t*  btog,
				 real_t*       tgt ,
				 const real_t* hbi ,
				 real_t*       work) const
// ---------------------------------------------------------------------------
// Create statically-condensed boundary Helmholtz forcing for this
// element from row-major F and insert it into globally-numbered tgt
// by direct stiffness summation.
//
// NB: forcing, F, is modified.
//
// On entry, F contains the elemental weak boundary-constrained forcing
//   - M f - H g.
//
// Elemental storage is then sorted in F so that it is ordered with boundary
// nodes foremost, i.e. it contains the partition { F | F }.
//                                                   b   i
//
// Statically-condensed boundary forcing is created in the first partition:
//                       -1                         -1
//   F   <--   F  -  h  h   F           (matrix h  h   supplied as hbi)
//    b         b     bi ii  i                   bi ii
//
// and summed into the tgt vector.  In the summation, there is no need
// to check if the global node is to be solved for or is fixed, since
// the fixed (essential-BC) partition of tgt is overwritten later.
//
// NB: scatr_sum is broken for self-periodic elements on vector machines!
//
// Work vector should be _npnp long.
// ---------------------------------------------------------------------------
{
  Veclib::gathr (_npnp, F, _emap, work);
  Veclib::copy  (_npnp, work, 1, F, 1);

  if (_nint) Blas::gemv ("T",_nint,_next, -1. ,hbi,_nint,F+_next,1, 1., F,1);

  Veclib::scatr_sum (_next, F, btog, tgt);
}


void Element::global2localSC (const real_t* RHS ,
			      const int_t*  btog,
			      real_t*       F   , 
			      real_t*       tgt ,
			      const real_t* hbi ,
			      const real_t* hii ,
			      real_t*       work) const
// ---------------------------------------------------------------------------
// Complete static condensation solution for internal values of Element.
//
// On entry, global-node solution values are in RHS and F contains the
// weak form of internal forcing in its top end (as installed by
// e2gSumSC).
//
// If u is current Element, compute internal solution according to:
//            -1      -1
//   u  <--  h  F  - h  h   u
//    i       ii i    ii ib  b
//
// Input vector work has length nTot().  F is overwritten during
// processing.
// ----------------------------------------------------------------------------
{
  // -- Load globally-numbered RHS into element-boundary storage.

  Veclib::gathr (_next, RHS,  btog, work);
  Veclib::scatr (_next, work, _emap, tgt );

  // -- Complete static-condensation solution for element-internal storage.

  if (_nint) {
    real_t* Fi   = F    + _next;
    real_t* wint = work + _next;

    Veclib::copy  (_nint, Fi, 1, wint, 1);
    Blas::gemv    ("T", _nint, _nint,  1.0, hii, _nint, wint, 1, 0.0, Fi, 1);
    Blas::gemv    ("N", _nint, _next, -1.0, hbi, _nint, work, 1, 1.0, Fi, 1);
    Veclib::scatr (_nint, Fi, _emap + _next, tgt);
  }
}


void Element::project (const int_t   nsrc,
		       const real_t* src ,
		       const int_t   ntgt,
		       real_t*       tgt ,
		       real_t*       work) const
// ---------------------------------------------------------------------------
// Project src (size nsrc*nsrc) to tgt (size ntgt*ntgt), using the
// current element's underlying family of shape functions.
//
// Work must be size nsrc*ntgt.
// ---------------------------------------------------------------------------
{
  const real_t *IN, *IT;

  Femlib::projection (0, &IT, nsrc, GLJ, 0.0, 0.0, ntgt, GLJ, 0.0, 0.0);
  Femlib::projection (&IN, 0, nsrc, GLJ, 0.0, 0.0, ntgt, GLJ, 0.0, 0.0);
  
  Blas::mxm (src, nsrc, IT,   nsrc, work, ntgt);
  Blas::mxm (IN,  ntgt, work, nsrc, tgt,  ntgt);
}



void Element::bndryDsSum (const int_t*  btog,
			  const real_t* src ,
			  real_t*       tgt ) const
// ---------------------------------------------------------------------------
// Direct-stiffness-sum from element boundary to globally-numbered
// storage, i.e. tgt[btog[i]] += mass[emap[i]] * src[emap[i]].  This
// is using in smoothing Fields along element boundaries.
// ---------------------------------------------------------------------------
{
  const int_t     loopcnt = _next; // -- Workaround for NEC vectorisation.
  register int_t  i, e;
  register real_t w;

  if (_cyl)
#if defined(__uxp__)
#pragma loop novrec
#elif defined(_SX)
#pragma vdir nodep
#endif
    for (i = 0; i < loopcnt; i++) {
      e = _emap[i];
      w = _Q4  [e];
      tgt[btog[i]] += (w > EPSDP) ? w * src[e] : src[e];
    }
  else
#if defined(__uxp__)
#pragma loop novrec
#elif defined(_SX)
#pragma vdir nodep
#endif
    for (i = 0; i < loopcnt; i++) {
      e = _emap[i];
      tgt[btog[i]] += _Q4[e] * src[e];
    }
}


void Element::bndryMask (const int_t*  bmsk,
			 real_t*       tgt ,
			 const real_t* src ,
			 const int_t*  btog) const
// ---------------------------------------------------------------------------
// Mask the values in (row-major) tgt according to the mask vector
// bmsk and optionally globally-numbered vector src.
//
// If src is non-zero, it is used with boundary-to-global mapping
// vector btog to impose values within tgt on locations where bmsk is
// non-zero; other locations are unaffected.
//
// If src is zero, then the values within tgt where bmsk is zero are
// set to zero (i.e. tgt itself is taken as the source).  Btog is then
// not used and may be zero also.
// ---------------------------------------------------------------------------
{
  register int_t i, e;
  const int_t    loopcnt = _next;

  if (src) {
    for (i = 0; i < _next; i++) {
      e = _emap[i];
      tgt[e] = (bmsk[i]) ? src[btog[i]] : tgt[e];
    }

  } else {
    vector<real_t>   work (_npnp);
    register real_t* tmp = &work[0];

    Veclib::gathr (_npnp, tgt, _emap, tmp);
    for (i = 0; i < loopcnt; i++)
      tmp[i] = (bmsk[i]) ? tmp[i] : 0.0;
    Veclib::zero  (_nint, tmp + _next, 1);
    Veclib::gathr (_npnp, tmp, _pmap, tgt);
  }
}


void Element::bndryInsert (const int_t*  b2g,
			   const real_t* src,
			   real_t*       tgt) const
// ---------------------------------------------------------------------------
// Load values from globally-numbered src around periphery of element
// tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, src, b2g, _emap, tgt);
}


void Element::grad (real_t* tgtX,
		    real_t* tgtY,
		    real_t* work) const
// ---------------------------------------------------------------------------
// Operate partial derivative d(tgt)/dxi = d_dr*drdxi + d_ds*dsdxi,
// where the appropriate component of gradient (x or y) is selected by
// input pointers.  Values are computed at node points.
//
// Work area must be 2*nTot() long.
// ---------------------------------------------------------------------------
{
  real_t* tmpA = work;
  real_t* tmpB = tmpA + _npnp;
  real_t* tgt;

  if ((tgt = tgtX)) {
    if (_drdx && _dsdx) {
      Blas::mxm     (tgt, _np, _DTr, _np, tmpA, _np);
      Blas::mxm     (_DVs, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdx, 1, tmpA, 1);
      Veclib::vvtvp (_npnp, tmpB, 1, _dsdx, 1, tmpA, 1, tgt, 1);
    } else if (_drdx) {
      Blas::mxm     (tgt, _np, _DTr, _np, tmpA, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdx, 1, tgt, 1);
    } else {
      Blas::mxm     (_DVs, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpB, 1, _dsdx, 1, tgt, 1);
    }
  }

  if ((tgt = tgtY)) {
    if (_drdy && _dsdy) {
      Blas::mxm     (tgt, _np, _DTr, _np, tmpA, _np);
      Blas::mxm     (_DVs, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdy, 1, tmpA, 1);
      Veclib::vvtvp (_npnp, tmpB, 1, _dsdy, 1, tmpA, 1, tgt, 1);
    } else if (_drdy) {
      Blas::mxm     (tgt, _np, _DTr, _np, tmpA, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdy, 1, tgt, 1);
    } else {
      Blas::mxm     (_DVs, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpB, 1, _dsdy, 1, tgt, 1);
    }
  }
}


void Element::gradX (const real_t* xr,
		     const real_t* xs,
		     real_t*       dx) const
// ---------------------------------------------------------------------------
// Partial implementation of x-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (_drdx && _dsdx) Veclib::vvtvvtp (_npnp, xr,1,_drdx,1,xs,1,_dsdx,1,dx,1);
  else if (_drdx)     Veclib::vmul    (_npnp, xr,1,_drdx,1,dx,1);
  else                Veclib::vmul    (_npnp, xs,1,_dsdx,1,dx,1);
}


void Element::gradY (const real_t* yr,
		     const real_t* ys,
		     real_t*       dy) const
// ---------------------------------------------------------------------------
// Partial implementation of y-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (_drdy && _dsdy) Veclib::vvtvvtp (_npnp, yr,1,_drdy,1,ys,1,_dsdy,1,dy,1);
  else if (_drdy)     Veclib::vmul    (_npnp, yr,1,_drdy,1,dy,1);
  else                Veclib::vmul    (_npnp, ys,1,_dsdy,1,dy,1);
}


void Element::sideEval (const int_t  side,
			real_t*      tgt ,
			const char*  func) const
// ---------------------------------------------------------------------------
// Evaluate function func along side of element, returning in tgt.
//
// The function can use variables "x", "y" & "t" (and any
// floating-point parameters previously set).
// ---------------------------------------------------------------------------
{
  vector<real_t> work(_np + _np);
  register int_t estart, skip;
  real_t         *x, *y;

  this -> terminal (side, estart, skip);

  x = &work[0];
  y = x + _np;

  Veclib::copy (_np, _xmesh + estart, skip, x, 1);
  Veclib::copy (_np, _ymesh + estart, skip, y, 1);

  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (_np, x, y, tgt);
}


void Element::sideGrad (const int_t   side,
			const real_t* src ,
			real_t*       c1  ,
			real_t*       c2  ,
			real_t*       work) const
// ---------------------------------------------------------------------------
// Using geometric factors for this Element, return the first and
// second component, c1 and/or c2, of grad src (length nTot()) along
// side.
//
// We have to take some special care on sides 2 & 3, where the usual
// skips are negative: we instead use positive skips for formation of
// dc/dr, dc/ds, then a -1 skip when multiplying by dr/dx, ds/dx, etc.
//
// Work vector is 2 * _np long.
// ---------------------------------------------------------------------------
{
  register int_t d, estart, skip;
  real_t         *ddr, *dds;

  this -> terminal (side, estart, skip);

  ddr = work;
  dds = ddr + _np;

  // -- Make dc/dr, dc/ds along element edge.

  switch (side) {
  case 0:
    d = 1;
    Blas::gemv ("T",_np,_np, 1.0,_DVr, _np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N",_np,_np, 1.0, src, _np,_DVs + estart, d*skip, 0.0, dds, 1);
    break;
  case 1:
    d = 1;
    Blas::gemv ("T",_np,_np, 1.0, src, _np,_DTr + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T",_np,_np, 1.0,_DVs, _np, src + estart, d*skip, 0.0, dds, 1);
    break;
  case 2:
    d = -1;
    Blas::gemv ("T",_np,_np, 1.0,_DVr, _np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N",_np,_np, 1.0, src, _np,_DVs + estart, d*skip, 0.0, dds, 1);
    break;
  case 3:
    d = -1;
    Blas::gemv ("T",_np,_np, 1.0, src, _np,_DTr + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T",_np,_np, 1.0,_DVs, _np, src + estart, d*skip, 0.0, dds, 1);
    break;
  }

  // -- dc/dx = dc/dr * dr/dx + dc/ds * ds/dx.

  if (c1) {
    if   (_drdx) Veclib::vmul  (_np, ddr, d, _drdx+estart, skip, c1, 1);
    else         Veclib::zero  (_np, c1, 1);
    if   (_dsdx) Veclib::vvtvp (_np, dds, d, _dsdx+estart, skip, c1, 1, c1, 1);
  }
  
  // -- dc/dy = dc/dr * dr/dy + dc/ds * ds/dy.

  if (c2) {
    if   (_drdy) Veclib::vmul  (_np, ddr, d, _drdy+estart, skip, c2, 1);
    else         Veclib::zero  (_np, c2, 1);
    if   (_dsdy) Veclib::vvtvp (_np, dds, d, _dsdy+estart, skip, c2, 1, c2, 1);
  }
}


void Element::sideGet (const int_t   side,
		       const real_t* src ,
		       real_t*       tgt ) const
// ---------------------------------------------------------------------------
// Load edge vector tgt with values from internal storage src.
// ---------------------------------------------------------------------------
{
  int_t start, skip;

  this -> terminal (side, start, skip);

  Veclib::copy (_np, src + start, skip, tgt, 1);
}


void Element::evaluate (const char* func,
			real_t*     tgt ) const
// ---------------------------------------------------------------------------
// Evaluate function over mesh points, store in tgt.  Function can
// explicitly use "x" and "y", for which mesh values are used.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (_npnp, _xmesh, _ymesh, tgt);
}


real_t Element::integral (const char* func,
			  real_t*     tmp ) const
// ---------------------------------------------------------------------------
// Return integral of func over element, using element quadrature
// rule.  In cylindrical space this includes weighting by radius.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec    ("x y", func);
  Femlib__parseVec   (_npnp, _xmesh, _ymesh, &tmp[0]);
  Veclib::vmul       (_npnp, &tmp[0], 1, _Q4, 1, &tmp[0], 1);
  return Veclib::sum (_npnp, &tmp[0], 1);
}


real_t Element::integral (const real_t* src,
			  real_t*       tmp) const
// ---------------------------------------------------------------------------
// Discrete approximation to the integral of element src vector.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, src, 1, _Q4, 1, tmp, 1);
  return Veclib::sum (_npnp, tmp, 1);
}


real_t Element::momentX (const char* func,
			 real_t*     tmp ) const
// ---------------------------------------------------------------------------
// The integral of func weighted by x location.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec    ("x y", func);
  Femlib__parseVec   (_npnp, _xmesh, _ymesh, &tmp[0]);
  Veclib::vvvtt      (_npnp, &tmp[0], 1, _Q4, 1, _xmesh, 1, &tmp[0], 1);
  return Veclib::sum (_npnp, &tmp[0], 1);
}


real_t Element::momentY (const char* func,
			 real_t*     tmp ) const
// ---------------------------------------------------------------------------
// The integral of func weighted by y location.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec    ("x y", func);
  Femlib__parseVec   (_npnp, _xmesh, _ymesh, &tmp[0]);
  Veclib::vvvtt      (_npnp, &tmp[0], 1, _Q4, 1, _ymesh, 1, &tmp[0], 1);
  return Veclib::sum (_npnp, &tmp[0], 1);
}


real_t Element::momentX (const real_t* src,
			 real_t*       tmp) const
// ---------------------------------------------------------------------------
// The integral weighted by x location.
// ---------------------------------------------------------------------------
{
  Veclib::vvvtt (_npnp, src, 1, _Q4, 1, _xmesh, 1, tmp, 1);
  return Veclib::sum (_npnp, tmp, 1);
}


real_t Element::momentY (const real_t* src,
			 real_t*       tmp) const
// ---------------------------------------------------------------------------
// The integral weighted by y location.
// ---------------------------------------------------------------------------
{
  Veclib::vvvtt (_npnp, src, 1, _Q4, 1, _ymesh, 1, tmp, 1);
  return Veclib::sum (_npnp, tmp, 1);
}


real_t Element::area () const
// ---------------------------------------------------------------------------
// Discrete approximation to area of element, using GLL quadrature.
//
// In cylindrical coords, it's integral(area * y).
// ---------------------------------------------------------------------------
{ 
  return Veclib::sum (_npnp, _Q4, 1);
}


void Element::weight (real_t* tgt) const
// ---------------------------------------------------------------------------
// Multiply tgt by elemental mass matrix. NB: not multiplied by radius.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, tgt, 1, _Q8, 1, tgt, 1);
}


void Element::lengthScale (real_t* tgt) const
// ---------------------------------------------------------------------------
// Load tgt with information about local elemental length scale.
// ---------------------------------------------------------------------------
{
  Veclib::copy (_npnp, _delta, 1, tgt, 1);
}


real_t Element::norm_inf (const real_t* src) const
// ---------------------------------------------------------------------------
// Return infinity-norm of element value.
// ---------------------------------------------------------------------------
{
  return fabs (src[Blas::iamax (_npnp, src, 1)]);
}


real_t Element::norm_L2 (const real_t* src) const
// ---------------------------------------------------------------------------
// Return L2-norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register int_t   i;
  register real_t  L2 = 0.0;
  register real_t* dA = _Q4;

  for (i = 0; i < _npnp; i++) L2 += src[i] * src[i] * dA[i];

  return sqrt (L2);
}


real_t Element::norm_H1 (const real_t* src) const
// ---------------------------------------------------------------------------
// Return Sobolev-1 norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register real_t H1 = 0;
  register int_t  i;
  vector<real_t>  work (3 * _npnp);
  register real_t *dA = _Q4, *u = &work[0], *gw = u + _npnp;

  // -- Add in L2 norm of u.

  for (i = 0; i < _npnp; i++) H1 += src[i] * src[i] * dA[i];

  // -- Add in L2 norm of grad u.

  Veclib::copy (_npnp, src, 1, u, 1);
  this -> grad (u, 0, gw);
  for (i = 0; i < _npnp; i++) H1 += u[i] * u[i] * dA[i];

  Veclib::copy (_npnp, src, 1, u, 1);
  this -> grad (0, u, gw);
  for (i = 0; i < _npnp; i++) H1 += u[i] * u[i] * dA[i];

  return sqrt (H1);
}


void Element::divY (real_t* src) const
// ---------------------------------------------------------------------------
// Divide src by y (i.e. r in cylindrical coordinates), take special
// action where r = 0.  This is used in taking theta component of
// gradient.
// ---------------------------------------------------------------------------
{
  const int_t      loopcnt = _npnp; // -- Workaround for NEC vectorisation.
  register int_t   i;
  register real_t  rad, rinv;
  register real_t* y = _ymesh;

  for (i = 0; i < loopcnt; i++) {
    rad     = y[i];
    rinv    = (rad > EPSDP) ? 1.0 / rad : 0.0;
    src[i] *= rinv;
  }
}


void Element::mulY (real_t* src) const
// ---------------------------------------------------------------------------
// Multiply src by y (i.e. r in cylindrical coordinates).
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, src, 1, _ymesh, 1, src, 1);
}


void Element::mulX (real_t* src) const
// ---------------------------------------------------------------------------
// Multiply src by x (i.e. axial distance in cylindrical coordinates).
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, src, 1, _xmesh, 1, src, 1);
}


void Element::sideGetY (const int_t side,
			real_t*     tgt ) const
// ---------------------------------------------------------------------------
// Load r (i.e. y) values for side into tgt.
// ---------------------------------------------------------------------------
{
  register int_t estart, skip;

  this -> terminal (side, estart, skip);

  Veclib::copy (_np, _ymesh + estart, skip, tgt, 1);
}


void Element::sideMulY (const int_t   side,
			const real_t* src ,
			real_t*       tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) multiplied
// by y (i.e. r).
// ---------------------------------------------------------------------------
{
  int_t        i, base, skip;
  real_t       *y;
  const real_t *s;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = _ymesh;
    s    = src;
    break;
  case 1:
    base = _np - 1;
    skip = _np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 2:
    base = _np * _np - 1;
    skip = -1;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 3:
    base = _np * (_np - 1);
    skip = -_np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  }

  Veclib::vmul (_np, s, skip, y, skip, tgt, 1);
}


void Element::sideDivY (const int_t   side,
			const real_t* src ,
			real_t*       tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y (i.e. r), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  int_t         i, base,  skip;
  real_t        r, rinv,  *y;
  const real_t* s;
  const int_t   loopcnt = _np;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = _ymesh;
    s    = src;
    break;
  case 1:
    base = _np - 1;
    skip = _np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 2:
    base = _np * _np - 1;
    skip = -1;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 3:
    base = _np * (_np - 1);
    skip = -_np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  }

  for (i = 0; i < loopcnt; i++) {
    r      = y[i*skip];
    rinv   = (r > EPSDP) ? 1.0 / r : 0.0;
    tgt[i] = rinv * s[i*skip];
  }
}


void Element::sideDivY2 (const int_t   side,
			 const real_t* src ,
			 real_t*       tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y^2 (i.e. r^2), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  register int_t        i, base, skip;
  register real_t       r, rinv2, *y;
  register const real_t *s;
  const int_t           loopcnt = _np;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = _ymesh;
    s    = src;
    break;
  case 1:
    base = _np - 1;
    skip = _np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 2:
    base = _np * _np - 1;
    skip = -1;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 3:
    base = _np * (_np - 1);
    skip = -_np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  }

  for (i = 0; i < loopcnt; i++) {
    r      = y[i*skip];
    rinv2  = (r > EPSDP) ? 1.0 / sqr(r) : 0.0;
    tgt[i] = rinv2 * s[i*skip];
  }
}


bool Element::locate (const real_t x    ,
		      const real_t y    ,
		      real_t&      r    ,
		      real_t&      s    ,
		      real_t*      work ,
		      const bool   guess) const
// ---------------------------------------------------------------------------
// If x & y fall in this element, compute the corresponding r & s
// values, and return true.  Otherwise return false.
//
// If guess = false (the default argument), the input value of (r, s)
// is used as an initial guess for N--R iteration.  Otherwise the (r,
// s) value that corresponds to the closest point in the Element mesh
// to (x, y) is used.
//
// Point tolerances can be changed by setting token TOL_POS, but as a
// first option it's better to increase NR_MAX above its default,
// since TOL_POS is used both as a location test at end of iteration,
// and on the N--R forcing term.
// ---------------------------------------------------------------------------
{
  static real_t EPS    = 0.0;
  static int_t  MaxItn = 0;
  const real_t  DIVERG = 20.0;
  real_t        *J, *F, *ir, *is, *dr, *ds, *tp, idet;
  int_t         i, j;
  
  tp = work;
  ir = tp + _np;
  is = ir + _np;
  dr = is + _np;
  ds = dr + _np;
  J  = ds + _np;
  F  = J  + 4;

  if (EPS  == 0.0) EPS    = Femlib:: value ("TOL_POS");
  if (MaxItn == 0) MaxItn = Femlib::ivalue ("NR_MAX");

  if (guess) {
    real_t *tx = work, *ty = work + _npnp;

    const real_t diag =
      max (hypot(_xmesh[_np*_np-1]  -_xmesh[0],
		 _ymesh[_np*_np-1]  -_ymesh[0])   ,
	   hypot(_xmesh[_np*(_np-1)]-_xmesh[_np-1],
		 _ymesh[_np*(_np-1)]-_ymesh[_np-1]));

    Veclib::ssub     (_npnp, x, _xmesh, 1, tx, 1);
    Veclib::ssub     (_npnp, y, _ymesh, 1, ty, 1);
    Veclib::vvtvvtp  (_npnp, tx, 1, tx, 1, ty, 1, ty, 1, tx, 1);
    
    i = Veclib::imin (_npnp, tx, 1);

    if (tx[i] - diag * diag > 0.0) {
#if defined (DEBUG)
      if (Femlib::ivalue("VERBOSE") > 3) cerr << "N" << endl;
#endif
      return false;
    }

    j = i % _np;
    i = (i - j) / _np;

    r = _zr[j];
    s = _zs[i];
#if 0
    if      (r >  0.999) r =  0.999;
    else if (r < -0.999) r = -0.999;
    if      (s >  0.999) s =  0.999;
    else if (s < -0.999) s = -0.999;
#endif
  }

  i = 0;
  do {
    Femlib::interpolation (ir,is,dr,ds,_np,GLJ,0.0,0.0,_np,GLJ,0.0,0.0,r,s);

               Blas::mxv (_xmesh, _np, ir, _np, tp);
    F[0] = x - Blas::dot (_np, is, 1, tp, 1);
    J[2] =     Blas::dot (_np, ds, 1, tp, 1);
               Blas::mxv (_ymesh, _np, ir, _np, tp);
    F[1] = y - Blas::dot (_np, is, 1, tp, 1);
    J[3] =     Blas::dot (_np, ds, 1, tp, 1);
               Blas::mxv (_xmesh, _np, dr, _np, tp);
    J[0] =     Blas::dot (_np, is, 1, tp, 1);
               Blas::mxv (_ymesh, _np, dr, _np, tp);
    J[1] =     Blas::dot (_np, is, 1, tp, 1);
#if 0
    // -- General/robust matrix solution routine.
    int_t ipiv[2], info;

    Lapack::gesv (2, 1, J, 2, ipiv, F, 2, info);
    
    r += F[0];
    s += F[1];
#else
    // -- Cramer's rule.
    idet = J[0]*J[3] - J[1]*J[2];
    idet = (fabs (idet) < EPSDP) ? 1.0/EPSDP : 1.0/idet;

    r   += (F[0]*J[3] - F[1]*J[2]) * idet;
    s   += (F[1]*J[0] - F[0]*J[1]) * idet;
#endif

    if (fabs (r) > DIVERG && fabs (s) > DIVERG) {
#if defined (DEBUG)
      if (Femlib::ivalue ("VERBOSE") > 3) cerr << "D" << endl;
#endif
      return false;
    }
  } while (++i < MaxItn && (fabs (F[0]) > EPS || fabs (F[1]) > EPS));

#if defined (DEBUG)
  if (Femlib::ivalue ("VERBOSE") > 3) {
    if (i == MaxItn) cerr << "M" << endl;
    else if (fabs (r) > 1.0 + EPS || fabs(s) > 1.0 + EPS) cerr << "O" << endl;
  }
#endif

  return
    (i < MaxItn && fabs (r) < 1.0 + EPS && fabs(s) < 1.0 + EPS) ?
    true : false;
}


real_t Element::probe (const real_t  r   ,
		       const real_t  s   ,
		       const real_t* src ,
		       real_t*       work) const
// ---------------------------------------------------------------------------
// Return the value of field storage located at r, s, in this element.
//
// Input vector work should be 3*_np long.
// ---------------------------------------------------------------------------
{
  real_t* ir = work;
  real_t* is = ir + _np;
  real_t* tp = is + _np;

  Femlib::interpolation (ir,is,0,0,_np,GLJ,0.0,0.0,_np,GLJ,0.0,0.0,r,s);

  Blas::mxv        (src, _np, ir, _np, tp);
  return Blas::dot (_np, is, 1, tp, 1);
}


real_t Element::CFL (const real_t  d   ,
		     const real_t* u   ,
		     const real_t* v   ,
		     real_t*       work) const
// ---------------------------------------------------------------------------
// Return estimate of local inverse timescale for CFL stability
// condition, for either the x or y velocity component, selected by
// input pointer.
//
//   CFL_x = max (|u| / dx),
//   CFL_y = max (|v| / dy),
//
// where dx or dy are estimated from local element geometric
// information:
//
//   dx = (dx/dr + dx/ds) * d,
//   dy = (dy/dr + dy/ds) * d,
//
// and d is a mesh spacing in canonical coordinates, estimated as the
// minimum to be conservative (and supplied as input).
//
// The local CFL number is then D_T * CFL.
// 
// Input vector work to be _npnp long.
// ---------------------------------------------------------------------------
{
  const int_t    loopcnt = _npnp;
  register int_t i;

  Veclib::zero (loopcnt, work, 1);

  if        (u) {
    if (_drdx) for (i = 0; i < loopcnt; i++) work[i] += d * fabs (_drdx[i]);
    if (_dsdx) for (i = 0; i < loopcnt; i++) work[i] += d * fabs (_dsdx[i]);
    Veclib::vdiv (loopcnt, u, 1, work, 1, work, 1);
  } else if (v) {
    if (_drdy) for (i = 0; i < loopcnt; i++) work[i] += d * fabs (_drdy[i]);
    if (_dsdy) for (i = 0; i < loopcnt; i++) work[i] += d * fabs (_dsdy[i]);
    Veclib::vdiv (loopcnt, v, 1, work, 1, work, 1);
  }

  i = Blas::iamax (loopcnt, work, 1);
  return fabs (work[i]);
}


void Element::mapping ()
// ---------------------------------------------------------------------------
// Generate geometric factors associated with mapping from 2D Cartesian to
// isoparametrically-mapped space:
//
//   dxdr, dydr, = dx/dr,  dy/dr,  "Forward Partials"
//   dxds, dyds, = dx/ds,  dy/ds.
//   drdx, drdy, = dr/dx,  dr/dy,  "Inverse Partials"
//   dsdx, dsdy, = ds/dx,  ds/dy.
//   jac         = dx/dr * dy/ds - dx/ds * dy/dr.
//
// The following relationships are used, where
//
//   IN[j][k] = h_k (x_j) is a Lagrangian interpolant matrix operator, and
//   DV[j][k] = h'_k(x_j) is a Lagrangian derivative  matrix operator,
//
// [ IT = transpose(IN), DT = transpose(DV) ]:
//
//   [dxdr] = [IN][X][DT];    [dydr] = [IN][Y][DT],
//   [dxds] = [DV][X][IT];    [dyds] = [DV][Y][IT].
//
// For a Gauss--Legendre quadrature rule, the inverse partials and
// mass matrix are returned for spatial locations at the mesh nodes,
// while the forward partials and other geometric factors are for
// spatial locations at the quadrature points.  In general, the amount
// of storage allocated for forward and inverse partials differ.
//
// For Lobatto--Legendre rule, everything is at the nodes, hence the
// interpolant matrices are identities.
// 
// The inverse partials are retained in Element storage, to be used in
// element gradient operations (e.g. dP/dx = dP/dr * dr/dx + dP/ds *
// ds/dx) while the forward partials are retained in scrambled form
// (in combination with quadrature weights) as "geometric factors"
// G1--G4, to be used in element quadrature operations.  For
// cylindrical geometries, Q1--Q4 are multiplied by y (i.e. r) as a
// consequence of the fact that Helmholtz equations are symmetrized by
// premultiplication by this factor for cylindrical coords.
//
// The local length-scale, delta, is a measure of the size of the
// local mesh length.
//
// Null-mapping optimizations mentioned below occur when the element
// geometry ensures that the entries of a vector are zero to within
// roundoff, due either to the edges of elements being aligned with
// coordinate axes (as can happen for the inverse partials) or if the
// element is an undistorted (but possibly rotated) rectangle (this
// applies to Q3).  In these cases the associated memory is deleted
// and the pointers are set to zero, so they can serve as flags in
// subsequent computations.
// ---------------------------------------------------------------------------
{
  const char     routine[] = "Element::mapping";
  const real_t   EPS  = 4 * EPSDP;
  const real_t   *x = _xmesh, *y = _ymesh;
  char           err[StrMax];
  real_t         *jac, *dxdr, *dxds, *dydr, *dyds, *tV, *WW;
  vector<real_t> work (7 * _npnp);

  dxdr = &work[0];
  dxds = dxdr + _npnp;
  dydr = dxds + _npnp;
  dyds = dydr + _npnp;
  jac  = dyds + _npnp;
  WW   = jac  + _npnp;
  tV   = WW   + _npnp;

  // -- Construct inverse mapping partials and Jacobian.
    
  Blas::mxm (x,    _np, _DTr, _np, dxdr, _np);
  Blas::mxm (_DVs, _np, x,    _np, dxds, _np);
  Blas::mxm (y,    _np, _DTr, _np, dydr, _np);
  Blas::mxm (_DVs, _np, y,    _np, dyds, _np);
    
  Veclib::vmul  (_npnp,        dxdr, 1, dyds, 1, tV,  1);
  Veclib::vvvtm (_npnp, tV, 1, dxds, 1, dydr, 1, jac, 1);

  if (jac[Veclib::imin (_npnp, jac, 1)] < EPS) {
    sprintf (err, "Jacobian of element %1d nonpositive", _id + 1);
    message (routine, err, ERROR);
  }

  // -- Construct quadrature weights.

  Veclib::zero  (_npnp, WW, 1);
  Blas::ger     (_np, _np, 1.0, _wr, 1, _ws, 1, WW, _np);

  Veclib::vmul  (_npnp, dyds, 1, dyds, 1, tV,  1);
  Veclib::vvtvp (_npnp, dxds, 1, dxds, 1, tV,  1, _Q1, 1);
  Veclib::vdiv  (_npnp, _Q1,  1, jac,  1, tV,  1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _Q1, 1);
    
  Veclib::vmul  (_npnp, dydr, 1, dydr, 1, tV,  1);
  Veclib::vvtvp (_npnp, dxdr, 1, dxdr, 1, tV,  1, _Q2, 1);
  Veclib::vdiv  (_npnp, _Q2,  1, jac,  1, tV,  1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _Q2, 1);
    
  Veclib::vmul  (_npnp, dydr, 1, dyds, 1, tV,    1);
  Veclib::neg   (_npnp, tV,   1);
  Veclib::vvvtm (_npnp, tV,   1, dxdr, 1, dxds,  1, _Q3, 1);
  Veclib::vdiv  (_npnp, _Q3,  1, jac,  1, tV,    1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _Q3,   1);
  
  Veclib::vmul  (_npnp, jac,  1, WW,   1, _Q4, 1);

  // -- Construct partials for derivative operations.

  Veclib::copy  (_npnp, dyds, 1, _drdx, 1);
  Veclib::vneg  (_npnp, dxds, 1, _drdy, 1);
  Veclib::vneg  (_npnp, dydr, 1, _dsdx, 1);
  Veclib::copy  (_npnp, dxdr, 1, _dsdy, 1);
    
  Veclib::vdiv  (_npnp, _drdx, 1, jac, 1, _drdx, 1);
  Veclib::vdiv  (_npnp, _drdy, 1, jac, 1, _drdy, 1);
  Veclib::vdiv  (_npnp, _dsdx, 1, jac, 1, _dsdx, 1);
  Veclib::vdiv  (_npnp, _dsdy, 1, jac, 1, _dsdy, 1);

  // -- Delta is a measure of the size of the local mesh length.
  //    This can be computed in various ways; we use the "hypotenuse"
  //    form: delta = sqrt{(dx^2 + dy^2 + dz^2)/3},
  //                ~ sqrt{(2*dA + dz^2)/3)}.
 
  Veclib::smul (_npnp, 2.0, _Q4, 1, _delta, 1);

  if (Geometry::nDim() == 3) {
    const real_t dz = Femlib::value ("TWOPI/(BETA*N_Z)");
    if (_cyl)
      Veclib::smul (_npnp, dz, _ymesh, 1, tV, 1);
    else
      Veclib::fill (_npnp, dz, tV, 1);
    Veclib::vmul (_npnp, tV, 1, tV, 1, tV, 1);
    Veclib::vadd (_npnp, tV, 1, _delta, 1, _delta, 1);
  }
  Blas::scal    (_npnp, 1.0/Geometry::nDim(), _delta, 1);
  Veclib::vsqrt (_npnp, _delta, 1, _delta, 1);

  // -- Premultiply r into the quadrature if a cylindrical computation.
  //    But note we don't do this for _Q8.

  Veclib::copy  (_npnp, _Q4, 1, _Q8, 1);

  if (_cyl) {
    Veclib::vmul (_npnp, _Q1, 1, y, 1, _Q1, 1);
    Veclib::vmul (_npnp, _Q2, 1, y, 1, _Q2, 1);
    Veclib::vmul (_npnp, _Q3, 1, y, 1, _Q3, 1);
    Veclib::vmul (_npnp, _Q4, 1, y, 1, _Q4, 1);
  } 

  // -- Calculations are done.  Do null-mapping optimizations.
  
  if (Blas::nrm2 (_npnp, _drdx, 1) < EPS) { delete [] _drdx; _drdx = 0; }
  if (Blas::nrm2 (_npnp, _drdy, 1) < EPS) { delete [] _drdy; _drdy = 0; }
  if (Blas::nrm2 (_npnp, _dsdx, 1) < EPS) { delete [] _dsdx; _dsdx = 0; }
  if (Blas::nrm2 (_npnp, _dsdy, 1) < EPS) { delete [] _dsdy; _dsdy = 0; }
  if (Blas::nrm2 (_npnp, _Q3,   1) < EPS) { delete [] _Q3;   _Q3   = 0; }
}


void Element::HelmholtzRow (const real_t lambda2,
			    const real_t betak2 ,
			    const int_t  i      ,
			    const int_t  j      ,
			    real_t*      hij    ,
			    real_t*      work   ) const
// ---------------------------------------------------------------------------
// Build row [i,j] of the elemental Helmholtz matrix in array hij (np x np).
//
// Lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Input array work should be at least np long.
//
// For a 2D tensor product form, the elemental Helmholtz matrix is produced
// as (sums on p & q indices assumed):
//
// h      = Q1  IN  DT  IN  DT     \
//  ij mn     pq  pi  jq  pm  nq   |
//        + Q2  DV  IT  DV  IT     |
//            pq  pi  jq  pm  nq   |
//        + Q3  DV  IT  IN  DT      >                              "STIFFNESS"
//            pq  pi  jq  pm  nq   |
//        + Q3  IN  DT  DV  IT     |
//            pq  pi  jq  pm  nq   /
//                
//        + Q4  IN  IT  IN  IT        (k2 / sqr (r  ) + lambda2)        "MASS"
//            pq  pi  jq  pm  nq                  pq
//
// where the terms Q1, Q2, Q3, Q4 contain geometric mapping factors
// and quadrature weights, and the matrices IN, IT are the Lagrangian
// interpolation matrix (from the nodes to the quadrature points) and
// its transpose, while DV, DT are the Lagrangian derivative matrix &
// transpose.  (For Lobatto quadrature, the only variant now
// implemented, the IN, IT matrices are identities).
//
// (The 1/r^2 factor in the mass matrix is only for cylindrical coordinates.)
// ---------------------------------------------------------------------------
{
  const real_t   r2   = sqr (_ymesh[Veclib::row_major(i,j,_np)]);
  const real_t   hCon = (_cyl && r2>EPSDP)?(betak2/r2+lambda2):betak2+lambda2;
  const real_t   *dtr, *dts, *dvr, *dvs;
  register int_t m, n;

  // -- If we are setting up a viscous matrix, use SVV-stabilised operators.

  if (lambda2 > EPSDP) { dvr = _SDVr; dtr = _SDTr; dvs = _SDVs; dts = _SDTs; }
  else                 { dvr =  _DVr; dtr =  _DTr; dvs =  _DVs; dts =  _DTs; }

  Veclib::zero (_npnp, hij, 1);

  for (n = 0; n < _np; n++) {
    Veclib::vmul (_np, dtr+j*_np, 1, dtr+n*_np, 1, work, 1);
    hij[Veclib::row_major(i,n,_np)]  = Blas::dot(_np,_Q1+i*_np,1,work,1);
  }

  for (m = 0; m < _np; m++) {
    Veclib::vmul (_np, dts+i*_np, 1, dts+m*_np, 1, work, 1);
    hij[Veclib::row_major(m,j,_np)] += Blas::dot (_np,_Q2+j,_np,work,1);
  }

  if (_Q3)
    for (m = 0; m < _np; m++)
      for (n = 0; n < _np; n++) {
	hij[Veclib::row_major(m,n,_np)] += _Q3[Veclib::row_major(i,n,_np)] *
	dvr[Veclib::row_major(n,j,_np)] *  dvs[Veclib::row_major(i,m,_np)] ;
	hij[Veclib::row_major(m,n,_np)] += _Q3[Veclib::row_major(m,j,_np)] *
	dvr[Veclib::row_major(j,n,_np)] *  dvs[Veclib::row_major(m,i,_np)] ;
      }

  hij[Veclib::row_major(i,j,_np)] += _Q4[Veclib::row_major(i,j,_np)] * hCon;
}


void Element::HelmholtzDiag (const real_t lambda2,
			     const real_t betak2 ,
			     real_t*      diag   ,
			     real_t*      work   ) const
// ---------------------------------------------------------------------------
// Create the diagonal of the elemental Helmholtz matrix in diag.  The
// diagonal is sorted in _emap order: i.e., boundary nodes are first.
//
// Input vector diag must be nTot() long, work must be Ntot() +
// nKnot() long.  Construction is very similar to that in helmRow
// except that m, n = i, j.
// ---------------------------------------------------------------------------
{
  register int_t  i, j, ij;
  register real_t *dg = work, *tmp = work + _npnp;
  const real_t    *dtr, *dts, *dvr, *dvs;
  real_t          r2, HCon;

  // -- If we are setting up a viscous matrix, use SVV-stabilised operators.

  if (lambda2 > EPSDP) { dvr = _SDVr; dtr = _SDTr; dvs = _SDVs; dts = _SDTs; }
  else                 { dvr =  _DVr; dtr =  _DTr; dvs =  _DVs; dts =  _DTs; }

  if (_cyl) {
    for (ij = 0, i = 0; i < _np; i++)
      for (j = 0; j < _np; j++, ij++) {
	r2   = sqr (_ymesh[ij]);
	HCon = (r2 > EPSDP) ? (betak2 / r2 + lambda2) : 0.0;
	Veclib::vmul (_np, dtr+j*_np, 1, dtr+j*_np, 1, tmp, 1);
	dg[ij] = Blas::dot (_np, _Q1 + i*_np, 1, tmp, 1);
	Veclib::vmul (_np, dts+i*_np, 1, dts+i*_np, 1, tmp, 1);
	dg[ij] += Blas::dot (_np, _Q2+j, _np, tmp, 1);
	if (_Q3) dg[ij] += 2.0 * _Q3[ij] * dvr[j*j] * dvs[i*i];
	dg[ij] += HCon * _Q4[ij];
      }
  } else {
    HCon = lambda2 + betak2;
    for (ij = 0, i = 0; i < _np; i++)
      for (j = 0; j < _np; j++, ij++) {
	Veclib::vmul (_np, dtr+j*_np, 1, dtr+j*_np, 1, tmp, 1);
	dg[ij]  = Blas::dot (_np, _Q1+i*_np, 1, tmp, 1);
	Veclib::vmul (_np, dts+i*_np, 1, dts+i*_np, 1, tmp, 1);
	dg[ij] += Blas::dot (_np, _Q2+j, _np, tmp, 1);
	if (_Q3) dg[ij] += 2.0 * _Q3[ij] * dvr[j*j] * dvs[i*i];
	dg[ij] += HCon * _Q4[ij];
      }
  }

  Veclib::gathr (_npnp, work, _emap, diag);
}


void Element::HelmholtzKern (const real_t lambda2,
			     const real_t betak2 ,
			     real_t*      R      ,
			     real_t*      S      ,
			     real_t*      src    ,
			     real_t*      tgt    ) const
// ---------------------------------------------------------------------------
// Apply kernel of elemental discrete Helmholtz operator on src to make tgt
// (if required, these can be the same storage locations).
//
// Lambda2 is the Helmholtz constant, betak2 is the mode Fourier constant.
// ---------------------------------------------------------------------------
{
  const int_t     loopcnt = _npnp; // -- Workaround for NEC vectorisation.
  register int_t  ij;
  register real_t tmp, r2, hCon;
  register real_t *g1 = _Q1, *g2 = _Q2, *g3 = _Q3, *g4 = _Q4, *r = _ymesh;

  if (_cyl) {
    if (g3) {
      for (ij = 0; ij < loopcnt; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPSDP) ? (betak2 / r2 + lambda2) : 0.0;
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < loopcnt; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPSDP) ? (betak2 / r2 + lambda2) : 0.0;
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }
  } else {			// -- Cartesian.
    hCon = betak2 + lambda2;
    if (g3) {
      for (ij = 0; ij < loopcnt; ij++) {
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < loopcnt; ij++) {
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }
  }
}


void Element::HelmholtzOp (const real_t lambda2,
			   const real_t betak2 ,
			   real_t*      src    ,
			   real_t*      tgt    ,
			   real_t*      wrk    ) const 
// ---------------------------------------------------------------------------
// Apply elemental Helmholtz operator on src to make tgt (if required,
// these can be the same storage locations).
//
// Lambda2 is the Helmholtz constant, betak2 is the mode Fourier constant.
//
// Input work must be 2*_npnp long.
// ---------------------------------------------------------------------------
{
  real_t *R = wrk, *S = wrk + _npnp;
  const real_t *dtr, *dts, *dvr, *dvs;

  // -- If we are setting up a viscous matrix, use SVV-stabilised operators.

  if (lambda2 > EPSDP) { dvr = _SDVr; dtr = _SDTr; dvs = _SDVs; dts = _SDTs; }
  else                 { dvr =  _DVr; dtr =  _DTr; dvs =  _DVs; dts =  _DTs; }
  
  Blas::mxm (src, _np, dtr, _np, R, _np);
  Blas::mxm (dvs, _np, src, _np, S, _np);

  this -> HelmholtzKern (lambda2, betak2, R, S, src, tgt);

  Blas::mxma (dts, _np, S,   _np, tgt, _np);
  Blas::mxma (R,   _np, dvr, _np, tgt, _np);
}


void Element::sideGeom (const int_t side,
			real_t*     x   ,
			real_t*     y   ,
			real_t*     nx  ,
			real_t*     ny  ,
			real_t*     area) const
// ---------------------------------------------------------------------------
// Generate unit outward normal components and change-of-variable
// Jacobian, area, for use in computation of edge integrals.
//
// We will always use Lobatto-Legendre quadrature for these integrals; 
// however, we need to do some recomputation of local forward partial
// derivatives along edges.
//
// Computed vectors have CCW edge-traverse ordering, i.e. are made to
// operate on vectors obtained from base storage using BLAS-conformant
// copy.
// ---------------------------------------------------------------------------
{
  if (side < 0 || side >= 4)
    message ("Element::sideGeom", "illegal side", ERROR);

  register int_t low, skip;
  real_t         *xr, *xs, *yr, *ys, *len;
  vector<real_t> work (_np + _np);

  switch (side) {
  case 0: 
    low  = 0;
    skip = 1;
    xr   = &work[0];
    yr   = xr + _np;
        
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
    Blas::gemv    ("T", _np, _np, 1.0, _DVr, _np, _xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", _np, _np, 1.0, _DVr, _np, _ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (_np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (_np, yr, 1, yr, 1, area, 1, area, 1);
    Veclib::vsqrt (_np, area, 1, area, 1);
    Veclib::vmul  (_np, area, 1, _wr,  1, area, 1);    

    if   (_dsdx) Veclib::smul (_np, -1.0, _dsdx, skip, nx, 1);
    else         Veclib::zero (_np,                    nx, 1);
    if   (_dsdy) Veclib::smul (_np, -1.0, _dsdy, skip, ny, 1);
    else         Veclib::zero (_np,                    ny, 1);

    break;

  case 1: 
    low  = _np - 1;
    skip = _np;
    xs   = &work[0];
    ys   = xs + _np;

    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", _np, _np, 1.0, _DVs, _np, _xmesh+low, _np, 0.0, xs, 1);
    Blas::gemv    ("T", _np, _np, 1.0, _DVs, _np, _ymesh+low, _np, 0.0, ys, 1);
    Veclib::vmul  (_np, xs, 1, xs, 1, area, 1);
    Veclib::vvtvp (_np, ys, 1, ys, 1, area, 1, area, 1);
    Veclib::vsqrt (_np, area, 1, area, 1);
    Veclib::vmul  (_np, area, 1, _ws,  1, area, 1);

    if   (_drdx) Veclib::copy (_np, _drdx+low, skip, nx, 1);
    else         Veclib::zero (_np,                  nx, 1);
    if   (_drdy) Veclib::copy (_np, _drdy+low, skip, ny, 1);
    else         Veclib::zero (_np,                  ny, 1);

    break;

  case 2:
    low  = _np * (_np - 1);
    skip = -1;
    xr   = &work[0];
    yr   = xr + _np;
    
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
	
    Blas::gemv    ("T", _np, _np, 1.0, _DVr, _np, _xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", _np, _np, 1.0, _DVr, _np, _ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (_np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (_np, yr, 1, yr, 1, area, 1, area, 1);
    Veclib::vsqrt (_np, area, 1, area, 1);
    Veclib::vmul  (_np, area, 1, _wr,  1, area, 1);

    if   (_dsdx) Veclib::copy (_np, _dsdx+low, skip, nx, 1);
    else         Veclib::zero (_np,                  nx, 1);
    if   (_dsdy) Veclib::copy (_np, _dsdy+low, skip, ny, 1);
    else         Veclib::zero (_np,                  ny, 1);

    break;

  case 3:
    low  = 0;
    skip = -_np;
    xs   = &work[0];
    ys   = xs + _np;
    
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", _np, _np, 1.0, _DVs, _np, _xmesh+low, _np, 0.0, xs, 1);
    Blas::gemv    ("T", _np, _np, 1.0, _DVs, _np, _ymesh+low, _np, 0.0, ys, 1);
    Veclib::vmul  (_np, xs, 1, xs, 1, area, 1);
    Veclib::vvtvp (_np, ys, 1, ys, 1, area, 1, area, 1);
    Veclib::vsqrt (_np, area, 1, area, 1);
    Veclib::vmul  (_np, area, 1, _ws,  1, area, 1);

    if   (_drdx) Veclib::smul (_np, -1.0, _drdx, skip, nx, 1);
    else         Veclib::zero (_np,                    nx, 1);
    if   (_drdy) Veclib::smul (_np, -1.0, _drdy, skip, ny, 1);
    else         Veclib::zero (_np,                    ny, 1);
  
    break;
  }
  
  len = &work[0];

  Veclib::vhypot (_np, nx, 1, ny,  1, len, 1);
  Veclib::vdiv   (_np, nx, 1, len, 1, nx,  1);
  Veclib::vdiv   (_np, ny, 1, len, 1, ny,  1);
}


void Element::crossXPlus (const int com, const real_t z, 
                          const vector<real_t>& a, real_t* tgt) const
// ---------------------------------------------------------------------------
// Add the com'th component of the cross product of a and X to tgt
// ---------------------------------------------------------------------------
{
  const int  c0[] = {1, 2, 0},	// -- lookup tables for 3-D vector product
             c1[] = {2, 0, 1};
  const real_t* mesh[] = {_xmesh, _ymesh};
  const int  bP = Geometry::basePlane ();
  const int  nz = Geometry::nZ();
  const int  nPlane = Geometry::nPlane ();
  double alpha;

  // Cartesian: z is constant, must be given
  // Cylindrical: since everything (vector a and the result) is in local
  //              coordinates, z is always zero

  if (com == 0) {
    if ((alpha = a[1] * z) != 0)
      Veclib::sadd (_npnp, alpha, tgt, 1, tgt, 1);
  } else {
    if (a[c0[com]] != 0)
      Blas::axpy (_npnp,  a[c0[com]], mesh[c1[com]], 1, tgt, 1);
  }
  if (com == 1) {
    if ((alpha = a[0] * z) != 0)
      Veclib::sadd (_npnp, -alpha, tgt, 1, tgt, 1);
    //
  } else {
    if (a[c1[com]] != 0)
      Blas::axpy (_npnp, -a[c1[com]], mesh[c0[com]], 1, tgt, 1);
  }
}
